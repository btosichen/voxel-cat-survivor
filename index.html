<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Voxel Cat Survivor - 喵喵倖存者</title>
    <!-- 引入 Three.js 3D 引擎 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- CSS 樣式表 --- */
        :root {
            --primary: #ff9900;
            --secondary: #2d2d2d;
            --accent: #00ffcc;
            --danger: #ff3333;
            --ui-font: 'Microsoft JhengHei', 'Segoe UI', Tahoma, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden; /* 防止捲軸出現 */
            background-color: #111;
            font-family: var(--ui-font);
            user-select: none; /* 禁止選取文字 */
        }

        /* 3D 畫布容器 */
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI 介面層 (覆蓋在 3D 上) */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* 讓點擊穿透到 Canvas，除非點到按鈕 */
        }

        /* HUD 資訊面板 */
        .hud-panel {
            position: absolute;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            color: white;
            font-weight: bold;
            pointer-events: auto;
            border: 2px solid rgba(255, 255, 255, 0.1);
            font-size: 16px;
        }

        #hud-top-left { top: 20px; left: 20px; }
        #hud-top-right { top: 20px; right: 20px; text-align: right; }

        /* 經驗值條 */
        #xp-bar-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            height: 20px;
            background: #333;
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
        }

        #xp-bar-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #00ffcc);
            transition: width 0.2s;
        }

        #level-indicator {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-weight: 900;
            font-size: 1.2rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        /* 全螢幕選單 (開始、結束、升級) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 3.5rem;
            color: var(--primary);
            margin-bottom: 10px;
            text-transform: uppercase;
            text-shadow: 4px 4px 0px #fff;
            letter-spacing: 2px;
            text-align: center;
        }
        
        h2 {
            color: white;
            font-size: 1.8rem;
            margin-bottom: 2rem;
        }

        /* 按鈕樣式 */
        .btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 153, 0, 0.4);
            margin: 10px;
        }

        .btn:hover {
            transform: scale(1.05);
            background: #ffaa33;
        }

        .btn:active { transform: scale(0.95); }

        /* 次要按鈕 (分享用) */
        .btn-secondary {
            background: #00aaff;
            box-shadow: 0 4px 15px rgba(0, 170, 255, 0.4);
        }
        .btn-secondary:hover { background: #33bbff; }

        /* 升級卡片 */
        #upgrade-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .upgrade-card {
            background: #222;
            border: 2px solid #444;
            padding: 20px;
            width: 220px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            color: white;
        }

        .upgrade-card:hover {
            background: #333;
            border-color: var(--primary);
            transform: translateY(-5px);
        }

        .upgrade-title {
            color: var(--primary);
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .upgrade-desc {
            font-size: 0.9rem;
            color: #ccc;
            line-height: 1.4;
        }

        /* 分享成功提示 (Toast) */
        #toast {
            visibility: hidden;
            min-width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 50px;
            padding: 16px;
            position: fixed;
            z-index: 100;
            left: 50%;
            bottom: 50px;
            transform: translateX(-50%);
            font-size: 1.1rem;
            border: 2px solid var(--accent);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #toast.show {
            visibility: visible;
            opacity: 1;
        }

        .stat-row { margin: 5px 0; }
        .highlight { color: var(--accent); }
    </style>
</head>
<body>

    <!-- 3D 場景容器 -->
    <div id="game-container"></div>

    <!-- UI 介面層 -->
    <div id="ui-layer">
        
        <!-- 分享提示框 -->
        <div id="toast">連結已複製！</div>

        <!-- 遊戲中 HUD -->
        <div id="hud" class="hidden">
            <div id="hud-top-left" class="hud-panel">
                <div class="stat-row">生命: <span id="hp-display" class="highlight">100/100</span></div>
                <div class="stat-row">波數: <span id="wave-display">1</span></div>
            </div>

            <div id="xp-bar-container">
                <div id="xp-bar-fill"></div>
            </div>
            <div id="level-indicator">LVL 1</div>

            <div id="hud-top-right" class="hud-panel">
                <div class="stat-row">分數: <span id="score-display" class="highlight">0</span></div>
                <div class="stat-row">時間: <span id="time-display">00:00</span></div>
            </div>
        </div>

        <!-- 開始畫面 -->
        <div id="start-screen" class="screen">
            <h1>喵喵倖存者</h1>
            <h2>體素大亂鬥</h2>
            <p style="color:#aaa; margin-bottom: 30px; max-width: 400px; text-align: center; line-height: 1.6;">
                使用 <b>WASD</b> 或 <b>方向鍵</b> 移動<br>
                角色會自動瞄準最近的敵人射擊<br>
                收集掉落的寶石來升級技能！
            </p>
            <button class="btn" onclick="game.start()">開始遊戲</button>
        </div>

        <!-- 升級選單 -->
        <div id="levelup-screen" class="screen hidden">
            <h1 style="font-size: 3rem; color: var(--accent);">等級提升！</h1>
            <p style="color: white;">請選擇一項強化能力</p>
            <div id="upgrade-container">
                <!-- JS 會在這裡插入卡片 -->
            </div>
        </div>

        <!-- 遊戲結束畫面 -->
        <div id="gameover-screen" class="screen hidden">
            <h1 style="color: var(--danger);">遊戲結束</h1>
            <div class="hud-panel" style="margin-bottom: 30px; text-align: center; min-width: 250px;">
                <div class="stat-row">存活時間: <span id="go-time" class="highlight"></span></div>
                <div class="stat-row">等級: <span id="go-level" class="highlight"></span></div>
                <div class="stat-row">總分: <span id="go-score" class="highlight"></span></div>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="btn" onclick="game.restart()">再玩一次</button>
                <button class="btn btn-secondary" onclick="game.share()">分享遊戲連結</button>
            </div>
        </div>

    </div>

    <script>
        // --- 音效系統 (Web Audio API) ---
        // 使用合成器產生音效，不需要下載 mp3
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const sfx = {
            playSound: (type) => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                const now = audioCtx.currentTime;
                
                if (type === 'shoot') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(400 + Math.random()*200, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'hit') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'collect') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, now);
                    osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0.001, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                } else if (type === 'levelup') {
                    gain.gain.value = 0.1;
                    gain.connect(audioCtx.destination);
                    // 簡單的和弦音效
                    [440, 554, 659, 880].forEach((freq, i) => {
                        const o = audioCtx.createOscillator();
                        o.type = 'triangle';
                        o.frequency.value = freq;
                        o.connect(gain);
                        o.start(now + i * 0.1);
                        o.stop(now + i * 0.1 + 0.3);
                    });
                    return; // 獨立處理
                }

                osc.connect(gain);
                gain.connect(audioCtx.destination);
            }
        };

        // --- 遊戲設定 ---
        const COLORS = {
            cat: 0xff9900,      // 橘貓
            catStripe: 0xcc7700,
            grass: 0x222222,    // 深色背景比較護眼
            grid: 0x333333,
            enemy: 0xff3333,    // 紅色敵人
            bullet: 0x00ffff,   // 青色子彈
            gem: 0x00ff00,      // 綠色寶石
            coin: 0xffd700
        };

        let scene, camera, renderer;
        let player, enemies = [], bullets = [], particles = [], loot = [];
        let lastTime = 0;
        let keys = {};
        
        // 遊戲狀態
        const gameState = {
            status: 'MENU', // MENU, PLAYING, PAUSED, GAMEOVER
            score: 0,
            time: 0,
            wave: 1,
            xp: 0,
            level: 1,
            nextLevelXp: 10,
            enemySpawnTimer: 0,
            enemySpawnRate: 1.5,
        };

        // 玩家數值
        const playerStats = {
            speed: 10,
            hp: 100,
            maxHp: 100,
            damage: 10,
            fireRate: 0.4,
            fireTimer: 0,
            projectiles: 1,
            projectileSpeed: 20,
            pickupRange: 5,
            bulletSize: 0.4
        };

        // --- Three.js 初始化 ---
        function initThree() {
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            
            // 設定相機 (等角視角 Isometric)
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(20, 30, 20); 
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // 燈光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // 地板
            const gridHelper = new THREE.GridHelper(100, 50, COLORS.grid, COLORS.grid);
            scene.add(gridHelper);
            
            const planeGeo = new THREE.PlaneGeometry(100, 100);
            const planeMat = new THREE.MeshStandardMaterial({ color: COLORS.grass });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            plane.receiveShadow = true;
            scene.add(plane);

            // 視窗縮放處理
            window.addEventListener('resize', () => {
                const aspect = window.innerWidth / window.innerHeight;
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 建立 3D 模型 (Voxel 風格) ---
        
        // 建立貓咪
        function createVoxelCat() {
            const group = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: COLORS.cat });
            const stripeMat = new THREE.MeshStandardMaterial({ color: COLORS.catStripe });

            // 身體
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1.5), bodyMat);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);

            // 頭
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), bodyMat);
            head.position.set(0, 1, 0.5);
            head.castShadow = true;
            group.add(head);

            // 耳朵
            const earGeo = new THREE.ConeGeometry(0.2, 0.4, 4);
            const earL = new THREE.Mesh(earGeo, stripeMat);
            earL.position.set(-0.3, 1.4, 0.5);
            earL.rotation.y = -0.5;
            const earR = new THREE.Mesh(earGeo, stripeMat);
            earR.position.set(0.3, 1.4, 0.5);
            earR.rotation.y = 0.5;
            group.add(earL, earR);

            // 尾巴
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.8), stripeMat);
            tail.position.set(0, 0.6, -0.8);
            tail.rotation.x = 0.5;
            group.add(tail);

            return group;
        }

        // 建立敵人
        function createVoxelEnemy(type = 'slime') {
            const group = new THREE.Group();
            let color = type === 'slime' ? 0x55ff55 : 0xff3333;
            if(type === 'boss') color = 0x8800ff;

            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2 });
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat);
            mesh.position.y = 0.5;
            mesh.castShadow = true;
            
            if(type === 'boss') {
                mesh.scale.set(2,2,2);
                mesh.position.y = 1;
            }

            group.add(mesh);
            group.userData = { type: type };
            return group;
        }

        // --- 遊戲邏輯 ---

        function spawnPlayer() {
            if (player) scene.remove(player);
            player = createVoxelCat();
            scene.add(player);
            
            // 重置數據
            playerStats.hp = playerStats.maxHp;
            playerStats.speed = 10;
            playerStats.damage = 10;
            playerStats.fireRate = 0.4;
            playerStats.projectiles = 1;
            playerStats.bulletSize = 0.4;
            playerStats.pickupRange = 5;

            gameState.xp = 0;
            gameState.level = 1;
            gameState.nextLevelXp = 10;
            gameState.time = 0;
            gameState.score = 0;
        }

        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 10; 
            const x = player.position.x + Math.cos(angle) * radius;
            const z = player.position.z + Math.sin(angle) * radius;

            const isBoss = Math.random() < 0.05 && gameState.time > 60;
            const enemy = createVoxelEnemy(isBoss ? 'boss' : 'slime');
            enemy.position.set(x, 0, z);
            
            // 難度隨時間增加
            const diffFactor = 1 + (gameState.time / 60);
            
            enemy.userData.hp = (isBoss ? 100 : 20) * diffFactor;
            enemy.userData.speed = (isBoss ? 3 : 4) + (gameState.time/120); 
            enemy.userData.damage = isBoss ? 20 : 10;
            
            scene.add(enemy);
            enemies.push(enemy);
        }

        // 玩家控制
        function updatePlayer(dt) {
            const moveDir = new THREE.Vector3(0, 0, 0);
            if (keys['ArrowUp'] || keys['w']) moveDir.z -= 1;
            if (keys['ArrowDown'] || keys['s']) moveDir.z += 1;
            if (keys['ArrowLeft'] || keys['a']) moveDir.x -= 1;
            if (keys['ArrowRight'] || keys['d']) moveDir.x += 1;

            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(playerStats.speed * dt);
                player.position.add(moveDir);
                player.lookAt(player.position.clone().add(moveDir));
                player.position.y = 0.5 + Math.sin(gameState.time * 15) * 0.1; // 走路跳動
            }

            // 限制邊界
            player.position.x = Math.max(-45, Math.min(45, player.position.x));
            player.position.z = Math.max(-45, Math.min(45, player.position.z));

            // 相機跟隨
            const targetPos = player.position.clone().add(new THREE.Vector3(20, 30, 20));
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(player.position);

            // 自動射擊
            playerStats.fireTimer -= dt;
            if (playerStats.fireTimer <= 0) {
                let nearest = null;
                let minDist = 20;
                
                enemies.forEach(e => {
                    const d = player.position.distanceTo(e.position);
                    if(d < minDist) { minDist = d; nearest = e; }
                });

                if (nearest) {
                    const dir = new THREE.Vector3().subVectors(nearest.position, player.position).normalize();
                    
                    // 散射邏輯
                    if (playerStats.projectiles === 1) {
                        createBullet(dir);
                    } else {
                        const spread = 0.3; 
                        const startAngle = -spread * (playerStats.projectiles - 1) / 2;
                        for(let i=0; i<playerStats.projectiles; i++) {
                            // 旋轉向量
                            const x = dir.x * Math.cos(startAngle + i*spread) - dir.z * Math.sin(startAngle + i*spread);
                            const z = dir.x * Math.sin(startAngle + i*spread) + dir.z * Math.cos(startAngle + i*spread);
                            createBullet(new THREE.Vector3(x, 0, z));
                        }
                    }
                    playerStats.fireTimer = playerStats.fireRate;
                }
            }
        }

        function createBullet(direction) {
            const geo = new THREE.BoxGeometry(playerStats.bulletSize, playerStats.bulletSize, playerStats.bulletSize);
            const mat = new THREE.MeshStandardMaterial({ color: COLORS.bullet, emissive: COLORS.bullet, emissiveIntensity: 0.8 });
            const bullet = new THREE.Mesh(geo, mat);
            
            bullet.position.copy(player.position);
            bullet.position.y = 0.8;
            
            bullet.userData = { 
                velocity: direction.normalize().multiplyScalar(playerStats.projectileSpeed), 
                life: 2 
            };
            scene.add(bullet);
            bullets.push(bullet);
            sfx.playSound('shoot');
        }

        // 敵人與子彈更新
        function updateEntities(dt) {
            // 更新敵人
            gameState.enemySpawnTimer -= dt;
            if (gameState.enemySpawnTimer <= 0) {
                spawnEnemy();
                gameState.enemySpawnTimer = Math.max(0.2, gameState.enemySpawnRate - (gameState.time * 0.005));
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
                e.position.add(dir.multiplyScalar(e.userData.speed * dt));
                e.lookAt(player.position);

                if (e.position.distanceTo(player.position) < 1.0) {
                    playerStats.hp -= e.userData.damage * dt;
                    updateHUD();
                    if (playerStats.hp <= 0) game.over();
                }
            }

            // 更新子彈
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.add(b.userData.velocity.clone().multiplyScalar(dt));
                b.userData.life -= dt;

                if (b.userData.life <= 0) {
                    scene.remove(b); bullets.splice(i, 1); continue;
                }

                // 碰撞檢測
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (b.position.distanceTo(e.position) < 1.2) {
                        e.userData.hp -= playerStats.damage;
                        sfx.playSound('hit');
                        
                        // 擊中粒子效果
                        createParticle(e.position, 0xff9900);

                        if (e.userData.hp <= 0) {
                            createParticle(e.position, 0xff3333, 8); // 死亡爆炸
                            createLoot(e.position, Math.random() > 0.8 ? 'coin' : 'xp');
                            scene.remove(e); enemies.splice(j, 1);
                            gameState.score += 100;
                        }
                        hit = true;
                        break; 
                    }
                }
                if (hit) { scene.remove(b); bullets.splice(i, 1); }
            }
        }

        function createLoot(pos, type) {
            const geo = type === 'xp' ? new THREE.OctahedronGeometry(0.3) : new THREE.BoxGeometry(0.3, 0.1, 0.3);
            const color = type === 'xp' ? COLORS.gem : COLORS.coin;
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: color, emissive: color }));
            mesh.position.copy(pos);
            mesh.position.y = 0.5;
            mesh.userData = { type: type, value: type==='xp'?10:50 };
            scene.add(mesh);
            loot.push(mesh);
        }

        function updateLoot(dt) {
            for (let i = loot.length - 1; i >= 0; i--) {
                const l = loot[i];
                const dist = l.position.distanceTo(player.position);
                
                if (dist < playerStats.pickupRange) {
                    const dir = new THREE.Vector3().subVectors(player.position, l.position).normalize();
                    l.position.add(dir.multiplyScalar(12 * dt));
                    
                    if (dist < 1.0) {
                        if (l.userData.type === 'xp') addXP(l.userData.value);
                        else gameState.score += l.userData.value;
                        sfx.playSound('collect');
                        scene.remove(l); loot.splice(i, 1);
                    }
                } else {
                    l.rotation.y += dt;
                }
            }
        }

        function createParticle(pos, color, count=3) {
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.userData = { vel: new THREE.Vector3((Math.random()-0.5)*5, Math.random()*5, (Math.random()-0.5)*5) };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function updateParticles(dt) {
            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel.clone().multiplyScalar(dt));
                p.userData.vel.y -= 9.8 * dt; // 重力
                p.scale.multiplyScalar(0.9);
                if(p.scale.x < 0.01 || p.position.y < 0) {
                    scene.remove(p); particles.splice(i, 1);
                }
            }
        }

        // --- 升級系統 ---
       // --- 升級系統 ---
        function addXP(amount) {
            gameState.xp += amount;

            // 先做一次升級判斷就好，夠用
            if (gameState.xp >= gameState.nextLevelXp) {
                gameState.xp -= gameState.nextLevelXp;
                gameState.level++;
                gameState.nextLevelXp = Math.floor(gameState.nextLevelXp * 1.5);
                showLevelUp();
            }

            updateHUD();
        }

   function showLevelUp() {
            // 暫停遊戲
            gameState.status = 'PAUSED';
            sfx.playSound('levelup');

            const upgrades = [
                { title: "鋒利貓爪", desc: "+20% 傷害", func: () => playerStats.damage *= 1.2 },
                { title: "貓步輕盈", desc: "+20% 移動速度", func: () => playerStats.speed *= 1.2 },
                { title: "瘋狂抓抓", desc: "+20% 攻擊速度", func: () => playerStats.fireRate *= 0.8 },
                { title: "影分身爪", desc: "+1 額外子彈", func: () => playerStats.projectiles += 1 },
                { title: "九命怪貓", desc: "回復 50% 血量 + 血量上限", func: () => {
                    playerStats.maxHp += 20;
                    playerStats.hp = Math.min(playerStats.hp + playerStats.maxHp / 2, playerStats.maxHp);
                }},
                { title: "巨大毛球", desc: "子彈變大 +10% 傷害", func: () => {
                    playerStats.bulletSize *= 1.3;
                    playerStats.damage *= 1.1;
                }}
            ];

            const container = document.getElementById('upgrade-container');
            container.innerHTML = '';

            // 隨機抽 3 張升級卡
            const choices = upgrades.sort(() => 0.5 - Math.random()).slice(0, 3);

            choices.forEach(u => {
                const div = document.createElement('div');
                div.className = 'upgrade-card';
                div.innerHTML = `
                    <div class="upgrade-title">${u.title}</div>
                    <div class="upgrade-desc">${u.desc}</div>
                `;

                div.addEventListener('click', () => {
                    // 套用升級效果
                    u.func();

                    // 關閉升級畫面，恢復遊戲
                    document.getElementById('levelup-screen').classList.add('hidden');
                    gameState.status = 'PLAYING';
                    lastTime = performance.now(); // 避免暫停期間累積超大 dt
                    updateHUD();

                    // 重新啟動動畫迴圈
                    requestAnimationFrame(animate);
                });

            container.appendChild(div);
        });

       // document.getElementById('levelup-screen').classList.remove('hidden');
    }

        // --- 遊戲流程控制 ---
        const game = {
            start: () => {
                spawnPlayer();
                enemies.forEach(e => scene.remove(e)); enemies = [];
                bullets.forEach(b => scene.remove(b)); bullets = [];
                loot.forEach(l => scene.remove(l)); loot = [];
                particles.forEach(p => scene.remove(p)); particles = [];

                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('gameover-screen').classList.add('hidden');
                document.getElementById('hud').classList.remove('hidden');
                
                gameState.status = 'PLAYING';
                lastTime = performance.now();
                requestAnimationFrame(animate);
            },
            restart: () => {
                game.start();
            },
            over: () => {
                gameState.status = 'GAMEOVER';
                document.getElementById('hud').classList.add('hidden');
                document.getElementById('gameover-screen').classList.remove('hidden');
                document.getElementById('go-score').innerText = gameState.score;
                document.getElementById('go-level').innerText = gameState.level;
                
                const mins = Math.floor(gameState.time / 60).toString().padStart(2, '0');
                const secs = Math.floor(gameState.time % 60).toString().padStart(2, '0');
                document.getElementById('go-time').innerText = `${mins}:${secs}`;
            },
            share: () => {
                const url = window.location.href;
                // 建立臨時元素以複製文字
                const tempInput = document.createElement("input");
                document.body.appendChild(tempInput);
                tempInput.value = url;
                tempInput.select();
                document.execCommand("copy");
                document.body.removeChild(tempInput);

                // 顯示提示 Toast
                const toast = document.getElementById('toast');
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 2000);
            }
        };

        function updateHUD() {
            document.getElementById('hp-display').innerText = `${Math.floor(playerStats.hp)}/${Math.floor(playerStats.maxHp)}`;
            document.getElementById('score-display').innerText = gameState.score;
            document.getElementById('wave-display').innerText = Math.floor(gameState.time/30)+1;
            document.getElementById('level-indicator').innerText = `LVL ${gameState.level}`;
            document.getElementById('xp-bar-fill').style.width = `${(gameState.xp / gameState.nextLevelXp) * 100}%`;
            
            const mins = Math.floor(gameState.time / 60).toString().padStart(2, '0');
            const secs = Math.floor(gameState.time % 60).toString().padStart(2, '0');
            document.getElementById('time-display').innerText = `${mins}:${secs}`;
        }

        function animate(now) {
            if (gameState.status !== 'PLAYING') return;
            requestAnimationFrame(animate);

            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            gameState.time += dt;

            updatePlayer(dt);
            updateEntities(dt);
            updateLoot(dt);
            updateParticles(dt);
            updateHUD();
            
            renderer.render(scene, camera);
        }

        // 鍵盤監聽
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        // 啟動 Three.js
        initThree();

    </script>
</body>
</html>
