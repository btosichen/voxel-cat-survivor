<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tabby Survivor: Voxel Chaos</title>
    <!-- Import Press Start 2P font for that retro arcade feel -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* --- CSS STYLES --- */
        :root {
            --primary: #ff9d00;
            --secondary: #ff0055;
            /* ÈÆÆË±îÁöÑÂ§©Á©∫ËóçËÉåÊôØ */
            --bg: #74b9ff;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Press Start 2P', cursive;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Canvas Container */
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* UI Overlays */
        .ui-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* ‰øùÊåÅÂçäÈÄèÊòéÈªëËâ≤ÈÅÆÁΩ©ÔºåËÆìÊñáÂ≠óÂú®‰∫ÆËâ≤ËÉåÊôØ‰∏ä‰πüÊ∏ÖÊ•ö */
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            text-align: center;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 3rem;
            color: var(--primary);
            text-shadow: 4px 4px var(--secondary);
            margin-bottom: 1rem;
            line-height: 1.2;
        }

        h2 {
            color: #fff;
            margin-bottom: 2rem;
            text-shadow: 2px 2px #000;
        }

        p {
            color: #eee;
            line-height: 1.6;
            font-size: 0.8rem;
            max-width: 600px;
            text-shadow: 1px 1px 2px black;
        }

        /* Buttons */
        .btn {
            background: var(--primary);
            border: 4px solid #fff;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: #000;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.1s, box-shadow 0.1s;
            text-transform: uppercase;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--primary);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-secondary {
            background: #444;
            color: #fff;
            border-color: #888;
        }

        /* HUD (Heads Up Display) */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .stats-box {
            display: flex;
            gap: 20px;
            font-size: 0.8rem;
            text-shadow: 2px 2px 0 #000;
        }

        /* XP Bar */
        .xp-container {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            max-width: 600px;
        }

        .bar-bg {
            width: 100%;
            height: 16px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 8px;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00c6ff, #0072ff);
            transition: width 0.2s ease-out;
        }

        /* HP Bar (Bottom Center) */
        .hp-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            text-align: center;
        }

        .hp-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0f0f, #ff8800);
            transition: width 0.1s linear;
        }

        /* Level Up Cards */
        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            width: 80%;
            max-width: 900px;
        }

        .upgrade-card {
            background: #222;
            border: 2px solid var(--primary);
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .upgrade-card:hover {
            background: #333;
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(255, 157, 0, 0.3);
        }

        .card-title {
            color: var(--primary);
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .card-desc {
            color: #ddd;
            font-size: 0.7rem;
            line-height: 1.4;
        }

        /* Result Stats */
        .stat-row {
            display: flex;
            justify-content: space-between;
            width: 300px;
            margin: 10px 0;
            border-bottom: 1px dashed #444;
            padding-bottom: 5px;
        }

        /* Damage Numbers / Floating Text */
        .floating-text {
            position: absolute;
            color: #fff;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 1px 1px 0 #000;
            font-size: 0.8rem;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        /* Notification */
        #notification {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 20;
        }
    </style>
</head>
<body>

    <!-- Notification Area (Level Up, etc.) -->
    <div id="notification"></div>

    <!-- 3D Container -->
    <div id="game-container"></div>

    <!-- Main Menu -->
    <div id="main-menu" class="ui-screen">
        <h1>TABBY SURVIVOR</h1>
        <p>You are a cute orange cat in a voxel world.</p>
        <p>Enemies are everywhere. You have auto-aim.</p>
        <p>WASD to Move. Survive.</p>
        <button id="start-btn" class="btn">START RUN</button>
    </div>

    <!-- HUD -->
    <div id="hud" class="hidden">
        <div class="hud-top">
            <div class="stats-box">
                <div>LVL <span id="hud-lvl">1</span></div>
                <div>ü™ô <span id="hud-coins">0</span></div>
                <div>‚ò†Ô∏è <span id="hud-kills">0</span></div>
            </div>
            <div class="stats-box">
                <div>‚è±Ô∏è <span id="hud-time">00:00</span></div>
            </div>
        </div>

        <div class="xp-container">
            <div class="bar-bg">
                <div id="xp-bar" class="xp-fill"></div>
            </div>
        </div>

        <div class="hp-container">
            <div style="margin-bottom:5px; font-size:0.7rem;">HP</div>
            <div class="bar-bg">
                <div id="hp-bar" class="hp-fill"></div>
            </div>
        </div>
    </div>

    <!-- Level Up Screen -->
    <div id="levelup-screen" class="ui-screen hidden">
        <h1 style="font-size: 2rem;">LEVEL UP!</h1>
        <p>Choose an upgrade</p>
        <div id="upgrade-container" class="upgrade-grid">
            <!-- JS will inject cards here -->
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameover-screen" class="ui-screen hidden">
        <h1 style="color: #ff3333;">GAME OVER</h1>
        <div id="results-stats">
            <div class="stat-row"><span>Time:</span> <span id="end-time">00:00</span></div>
            <div class="stat-row"><span>Level:</span> <span id="end-lvl">1</span></div>
            <div class="stat-row"><span>Kills:</span> <span id="end-kills">0</span></div>
            <div class="stat-row"><span>Coins:</span> <span id="end-coins">0</span></div>
        </div>
        <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
            <button id="restart-btn" class="btn">PLAY AGAIN</button>
            <button id="share-btn" class="btn btn-secondary">COPY</button>
            <!-- Facebook ÊåâÈàï -->
            <button id="fb-btn" class="btn" style="background:#1877F2; border-color:#fff; color:#fff;">FB SHARE</button>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /* --- AUDIO SYSTEM (NEW) --- */
        const AUDIO = {
            ctx: null,
            init: function() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    this.ctx = new AudioContext();
                }
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            shoot: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },
            explosion: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            },
            coin: function() {
                this.playTone(1200, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(1800, 'sine', 0.2, 0.1), 50);
            },
            hit: function() {
                this.playTone(150, 'sawtooth', 0.1, 0.1);
            },
            levelup: function() {
                if (!this.ctx) return;
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C Major Arpeggio
                notes.forEach((note, i) => {
                    setTimeout(() => this.playTone(note, 'square', 0.2, 0.1), i * 100);
                });
            }
        };

        /* --- JAVASCRIPT GAME ENGINE --- */

        /** * CONFIGURATION & CONSTANTS
         */
        const CONFIG = {
            arenaSize: 100,
            playerSpeed: 12,
            cameraHeight: 25,
            cameraOffsetZ: 20,
            baseXp: 10,
            spawnRate: 1.0 // seconds
        };

        /** * GAME STATE
         */
        const GAME = {
            active: false,
            paused: false,
            time: 0,
            lastFrame: 0,
            
            // Player Stats
            player: {
                hp: 100,
                maxHp: 100,
                lvl: 1,
                xp: 0,
                xpNext: 50,
                coins: 0,
                kills: 0,
                
                // Combat Stats
                damage: 10,
                fireRate: 0.5, // seconds between shots
                speed: CONFIG.playerSpeed,
                range: 20,
                projectiles: 1,
                bulletSpeed: 30,
                bulletSize: 0.5
            },
            
            // Entities
            enemies: [],
            bullets: [],
            particles: [],
            drops: [],
            
            // Difficulty
            difficultyMult: 1
        };

        // Upgrade Pool
        const UPGRADES = [
            { id: 'dmg', name: "Razor Claws", desc: "+30% Damage", apply: (p) => p.damage *= 1.3 },
            { id: 'spd', name: "Zoomies", desc: "+15% Move Speed", apply: (p) => p.speed *= 1.15 },
            { id: 'rate', name: "Catnip Rush", desc: "+20% Fire Rate", apply: (p) => p.fireRate *= 0.8 },
            { id: 'multi', name: "Twin Claw", desc: "+1 Projectile", apply: (p) => p.projectiles += 1 },
            { id: 'hp', name: "Nine Lives", desc: "Heal 50% + Max HP Up", apply: (p) => { p.maxHp += 20; p.hp = Math.min(p.hp + p.maxHp*0.5, p.maxHp); } },
            { id: 'size', name: "Big Chonk", desc: "Larger Projectiles", apply: (p) => { p.bulletSize *= 1.5; p.damage *= 1.1; } }
        ];

        /**
         * THREE.JS SETUP
         */
        const scene = new THREE.Scene();
        // ÈÆÆË±îÁöÑÂ§©Á©∫ËóçËÉåÊôØ
        scene.background = new THREE.Color(0x74b9ff);
        // ÈúßÊ∞£È°èËâ≤ÈÖçÂêàËÉåÊôØ
        scene.fog = new THREE.Fog(0x74b9ff, 20, 70);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 30, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        scene.add(dirLight);

        // Floor
        // Á∂≤Ê†ºÁ∑öÊîπÁÇ∫Ê∑∫Ëâ≤
        const gridHelper = new THREE.GridHelper(CONFIG.arenaSize, 20, 0xffffff, 0x555555);
        scene.add(gridHelper);

        const floorGeo = new THREE.PlaneGeometry(CONFIG.arenaSize, CONFIG.arenaSize);
        // Âú∞ÊùøÊîπÁÇ∫ËçâÂú∞Á∂†Ëâ≤
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x81c784 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        /**
         * GEOMETRY BUILDER HELPER (Updated for multiple shapes)
         * ÂçáÁ¥öÁâàÁöÑÂπæ‰ΩïÂª∫ÊßãÂáΩÊï∏ÔºåÊîØÊè¥ Box, Sphere, Cylinder, Cone, Dodecahedron, Icosahedron
         */
        function createVoxelGroup(parts) {
            const group = new THREE.Group();
            parts.forEach(p => {
                let geo;
                
                // Ê†πÊìö type Â±¨ÊÄßÊ±∫ÂÆöÂΩ¢ÁãÄ
                switch(p.type) {
                    case 'sphere':
                        // ÂèÉÊï∏: ÂçäÂæë(w/2), Ê∞¥Âπ≥ÂàÜÊÆµÊï∏, ÂûÇÁõ¥ÂàÜÊÆµÊï∏
                        geo = new THREE.SphereGeometry(p.w / 2, 16, 16);
                        break;
                    case 'cylinder':
                        // ÂèÉÊï∏: È†ÇÈÉ®ÂçäÂæë, Â∫ïÈÉ®ÂçäÂæë, È´òÂ∫¶, ÂàÜÊÆµÊï∏
                        geo = new THREE.CylinderGeometry(p.w / 2, p.w / 2, p.h, 16);
                        break;
                    case 'cone':
                        // ÂèÉÊï∏: ÂçäÂæë, È´òÂ∫¶, ÂàÜÊÆµÊï∏
                        geo = new THREE.ConeGeometry(p.w / 2, p.h, 16);
                        break;
                    case 'dodecahedron':
                        // ÂèÉÊï∏: ÂçäÂæë
                        geo = new THREE.DodecahedronGeometry(p.w / 2);
                        break;
                    case 'icosahedron':
                        // ÂèÉÊï∏: ÂçäÂæë
                        geo = new THREE.IcosahedronGeometry(p.w / 2);
                        break;
                    default: // È†êË®≠ÁÇ∫ 'box' (Á´ãÊñπÈ´î)
                        geo = new THREE.BoxGeometry(p.w, p.h, p.d);
                        break;
                }

                const mat = new THREE.MeshLambertMaterial({ color: p.c });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(p.x, p.y, p.z);
                
                // È°çÂ§ñÁöÑÊóãËΩâÂèÉÊï∏ (‰∏ªË¶ÅÁî®ÊñºÂúìÊü±È´îÂíåÂúìÈåêÈ´îÁöÑË™øÊï¥)
                if (p.rx) mesh.rotation.x = p.rx;
                if (p.rz) mesh.rotation.z = p.rz;

                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);
            });
            return group;
        }

        /**
         * PLAYER (THE TABBY CAT) - Updated with Mixed Geometry
         * Ê∑∑Âêà‰∫ÜÁêÉÈ´î„ÄÅÂúìÈåê„ÄÅÂúìÊü±ÂíåÁ´ãÊñπÈ´îÁöÑË≤ì
         */
        const playerMesh = createVoxelGroup([
            // Body (Box - Ë∫´È´î‰øùÊåÅÊñπÂ°äÔºå‰øùÁïô‰∏ÄÈªûÈ´îÁ¥†È¢®Ê†º)
            { type: 'box', w: 0.8, h: 0.8, d: 1.2, c: 0xff9d00, x: 0, y: 0.4, z: 0 }, 
            
            // Head (Sphere - È†≠ËÆäÊàêÂúìÁêÉ)
            { type: 'sphere', w: 0.75, h: 0.75, d: 0.75, c: 0xff9d00, x: 0, y: 1.1, z: 0.5 },
            
            // Ear L (Cone - Â∑¶ËÄ≥ËÆäÊàêÂúìÈåê)
            { type: 'cone', w: 0.3, h: 0.4, d: 0.3, c: 0xffffff, x: -0.25, y: 1.55, z: 0.5, rx: -0.2, rz: 0.2 },
            
            // Ear R (Cone - Âè≥ËÄ≥ËÆäÊàêÂúìÈåê)
            { type: 'cone', w: 0.3, h: 0.4, d: 0.3, c: 0xffffff, x: 0.25, y: 1.55, z: 0.5, rx: -0.2, rz: -0.2 },
            
            // Tail (Cylinder - Â∞æÂ∑¥ËÆäÊàêÂúìÊü±)
            { type: 'cylinder', w: 0.15, h: 0.8, d: 0.15, c: 0xcc7700, x: 0, y: 0.6, z: -0.8, rx: Math.PI/2.5 } 
        ]);
        scene.add(playerMesh);

        /**
         * INPUT HANDLING
         */
        const keys = { w: false, a: false, s: false, d: false };
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (keys.hasOwnProperty(k) || k === 'arrowup' || k === 'arrowleft' || k === 'arrowdown' || k === 'arrowright') {
                if(k === 'arrowup') keys.w = true;
                else if(k === 'arrowdown') keys.s = true;
                else if(k === 'arrowleft') keys.a = true;
                else if(k === 'arrowright') keys.d = true;
                else keys[k] = true;
            }
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if (keys.hasOwnProperty(k) || k === 'arrowup' || k === 'arrowleft' || k === 'arrowdown' || k === 'arrowright') {
                if(k === 'arrowup') keys.w = false;
                else if(k === 'arrowdown') keys.s = false;
                else if(k === 'arrowleft') keys.a = false;
                else if(k === 'arrowright') keys.d = false;
                else keys[k] = false;
            }
        });

        /**
         * LOGIC: SHOOTING & BULLETS
         */
        let shootTimer = 0;
        
        function spawnBullet(targetPos) {
            const count = GAME.player.projectiles;
            
            // Sound: Shoot
            AUDIO.shoot();

            for(let i = 0; i < count; i++) {
                // Simple Spread logic
                const offsetAngle = (i - (count-1)/2) * 0.2;
                
                const bulletGeo = new THREE.BoxGeometry(GAME.player.bulletSize, GAME.player.bulletSize, GAME.player.bulletSize);
                const bulletMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const bullet = new THREE.Mesh(bulletGeo, bulletMat);
                bullet.position.copy(playerMesh.position);
                bullet.position.y = 0.5;
                
                // Calculate direction
                const direction = new THREE.Vector3().subVectors(targetPos, playerMesh.position).normalize();
                direction.applyAxisAngle(new THREE.Vector3(0,1,0), offsetAngle);
                
                scene.add(bullet);
                GAME.bullets.push({
                    mesh: bullet,
                    vel: direction.multiplyScalar(GAME.player.bulletSpeed),
                    life: 1.5 // seconds
                });
            }
        }

        /**
         * LOGIC: ENEMIES (Updated with various shapes)
         * ÁèæÂú®Êïµ‰∫∫ÊúÉ‰ΩøÁî®ÔºöÂçÅ‰∫åÈù¢È´î(Tank), ÂúìÈåêÈ´î(Fast), ÁêÉÈ´î(Basic)
         */
        let spawnTimer = 0;
        
        function spawnEnemy() {
            const type = Math.random();
            let hp, speed, color, scale, shapeType;

            if(type > 0.8) { 
                // Tank Enemy: Blue Dodecahedron (Strong)
                hp = 50 * GAME.difficultyMult;
                speed = 2;
                color = 0x3333ff;
                scale = 1.5;
                shapeType = 'dodecahedron';
            } else if (type > 0.6) { 
                // Fast Enemy: Green Cone (Fast, aerodynamic)
                hp = 15 * GAME.difficultyMult;
                speed = 7;
                color = 0x00ff00;
                scale = 0.8;
                shapeType = 'cone';
            } else { 
                // Basic Enemy: Red Sphere (Standard)
                hp = 30 * GAME.difficultyMult;
                speed = 4;
                color = 0xff3333;
                scale = 1.0;
                shapeType = 'sphere';
            }

            const group = createVoxelGroup([
                { type: shapeType, w: 1, h: 1, d: 1, c: color, x: 0, y: 0.5, z: 0, rx: shapeType === 'cone' ? Math.PI/2 : 0 }
            ]);
            group.scale.set(scale, scale, scale);

            // Random position on perimeter
            const angle = Math.random() * Math.PI * 2;
            const radius = 35;
            group.position.set(
                playerMesh.position.x + Math.cos(angle) * radius,
                0,
                playerMesh.position.z + Math.sin(angle) * radius
            );

            scene.add(group);
            GAME.enemies.push({
                mesh: group,
                hp: hp,
                maxHp: hp,
                speed: speed,
                damage: 10
            });
        }

        /**
         * LOGIC: PARTICLES
         */
        function spawnParticles(pos, color, count) {
            for(let i=0; i<count; i++) {
                const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 10
                );

                scene.add(mesh);
                GAME.particles.push({ mesh, vel, life: 1.0 });
            }
        }

        /**
         * LOGIC: DROPS (XP/Coins)
         */
        function spawnDrop(pos, type) {
            const color = type === 'xp' ? 0x00aaff : 0xffd700;
            const geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.position.y = 0.5;
            
            scene.add(mesh);
            GAME.drops.push({ mesh, type, value: type === 'xp' ? 10 : 1 });
        }

        /**
         * UI UPDATES
         */
        function updateHUD() {
            document.getElementById('hud-lvl').innerText = GAME.player.lvl;
            document.getElementById('hud-coins').innerText = GAME.player.coins;
            document.getElementById('hud-kills').innerText = GAME.player.kills;
            
            // Time
            const m = Math.floor(GAME.time / 60).toString().padStart(2, '0');
            const s = Math.floor(GAME.time % 60).toString().padStart(2, '0');
            document.getElementById('hud-time').innerText = `${m}:${s}`;

            // Bars
            const xpPct = (GAME.player.xp / GAME.player.xpNext) * 100;
            document.getElementById('xp-bar').style.width = `${xpPct}%`;

            const hpPct = (GAME.player.hp / GAME.player.maxHp) * 100;
            document.getElementById('hp-bar').style.width = `${hpPct}%`;
        }

        /**
         * LEVEL UP SYSTEM
         */
        function checkLevelUp() {
            if (GAME.player.xp >= GAME.player.xpNext) {
                // Sound: Level Up
                AUDIO.levelup();

                GAME.player.xp -= GAME.player.xpNext;
                GAME.player.lvl++;
                GAME.player.xpNext = Math.floor(GAME.player.xpNext * 1.3);
                
                pauseGameForUpgrade();
            }
        }

        function pauseGameForUpgrade() {
            GAME.paused = true;
            document.getElementById('levelup-screen').classList.remove('hidden');
            
            const container = document.getElementById('upgrade-container');
            container.innerHTML = '';

            // Pick 3 random
            const opts = [];
            for(let i=0; i<3; i++) {
                opts.push(UPGRADES[Math.floor(Math.random() * UPGRADES.length)]);
            }

            opts.forEach(opt => {
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `<div class="card-title">${opt.name}</div><div class="card-desc">${opt.desc}</div>`;
                card.onclick = () => {
                    opt.apply(GAME.player);
                    resumeGame();
                };
                container.appendChild(card);
            });
        }

        function resumeGame() {
            document.getElementById('levelup-screen').classList.add('hidden');
            GAME.paused = false;
            // Heal slightly on level up
            GAME.player.hp = Math.min(GAME.player.hp + 20, GAME.player.maxHp);
            
            const notif = document.getElementById('notification');
            notif.innerText = "UPGRADE EQUIPPED!";
            notif.style.opacity = 1;
            setTimeout(() => notif.style.opacity = 0, 1500);
        }

        /**
         * GAME LOOP
         */
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            // --- ‰øÆÂæ©ÈáçÈªû ---
            // ÁÑ°Ë´ñÈÅäÊà≤ÊòØÂê¶Êö´ÂÅúÔºåÈÉΩË¶ÅÊØè‰∏ÄÂπÄÂëºÂè´ getDelta() ÊääÊôÇÈñìÂ∑Æ„ÄåÊ∂àËÄóÊéâ„Äç„ÄÇ
            // ÈÄôÊ®£Áï∂ÈÅäÊà≤Êö´ÂÅúÊôÇÔºådelta ÊúÉË¢´Ë®àÁÆóÂá∫‰æÜ‰ΩÜË¢´‰∏ãÈù¢ÁöÑ if (paused) ÂøΩÁï•„ÄÇ
            // Áï∂ÈÅäÊà≤ÊÅ¢Âæ©ÊôÇÔºådelta ‰æùÁÑ∂ÊòØÁü≠Áü≠ÁöÑ 0.016ÁßíÔºåËÄå‰∏çÊúÉÊòØÁ¥ØÁ©çÁöÑ 10Áßí„ÄÇ
            const delta = clock.getDelta(); 

            // 1. Always render
            renderer.render(scene, camera);

            // 2. Only update Logic if Active and Not Paused
            if (!GAME.active || GAME.paused) return;

            // ÈÄôË£°ÂéüÊú¨ÊòØ const delta = clock.getDelta(); (Â∞éËá¥BugÁöÑÂéüÂõ†)

            GAME.time += delta;
            GAME.difficultyMult = 1 + (GAME.time / 60) * 0.5;

            // --- PLAYER MOVEMENT ---
            const moveVec = new THREE.Vector3(0, 0, 0);
            if (keys.w) moveVec.z -= 1;
            if (keys.s) moveVec.z += 1;
            if (keys.a) moveVec.x -= 1;
            if (keys.d) moveVec.x += 1;

            if (moveVec.length() > 0) {
                moveVec.normalize().multiplyScalar(GAME.player.speed * delta);
                playerMesh.position.add(moveVec);
                const angle = Math.atan2(moveVec.x, moveVec.z);
                playerMesh.rotation.y = angle;
            }

            // Camera Follow
            camera.position.x = playerMesh.position.x;
            camera.position.z = playerMesh.position.z + CONFIG.cameraOffsetZ;
            camera.position.y = CONFIG.cameraHeight;
            camera.lookAt(playerMesh.position);

            // --- SHOOTING ---
            shootTimer += delta;
            if (shootTimer >= GAME.player.fireRate) {
                let nearest = null;
                let dist = GAME.player.range;
                GAME.enemies.forEach(e => {
                    const d = playerMesh.position.distanceTo(e.mesh.position);
                    if (d < dist) {
                        dist = d;
                        nearest = e;
                    }
                });

                if (nearest) {
                    spawnBullet(nearest.mesh.position);
                    shootTimer = 0;
                }
            }

            // --- BULLETS ---
            for (let i = GAME.bullets.length - 1; i >= 0; i--) {
                const b = GAME.bullets[i];
                b.life -= delta;
                b.mesh.position.add(b.vel.clone().multiplyScalar(delta));
                b.mesh.rotation.x += 10 * delta;

                if (b.life <= 0) {
                    scene.remove(b.mesh);
                    GAME.bullets.splice(i, 1);
                    continue;
                }

                for (let j = GAME.enemies.length - 1; j >= 0; j--) {
                    const e = GAME.enemies[j];
                    if (b.mesh.position.distanceTo(e.mesh.position) < 1.5) {
                        e.hp -= GAME.player.damage;
                        spawnParticles(b.mesh.position, 0xffaa00, 3);
                        scene.remove(b.mesh);
                        GAME.bullets.splice(i, 1);
                        if (e.hp <= 0) {
                            // Sound: Explosion
                            AUDIO.explosion();
                            spawnParticles(e.mesh.position, 0xff3333, 8);
                            spawnDrop(e.mesh.position, Math.random() > 0.8 ? 'coin' : 'xp');
                            scene.remove(e.mesh);
                            GAME.enemies.splice(j, 1);
                            GAME.player.kills++;
                        }
                        break;
                    }
                }
            }

            // --- ENEMIES ---
            spawnTimer += delta;
            if (spawnTimer >= (CONFIG.spawnRate / GAME.difficultyMult)) {
                spawnEnemy();
                spawnTimer = 0;
            }

            GAME.enemies.forEach(e => {
                const dir = new THREE.Vector3().subVectors(playerMesh.position, e.mesh.position).normalize();
                e.mesh.position.add(dir.multiplyScalar(e.speed * delta));
                e.mesh.lookAt(playerMesh.position);
                
                // Rotate enemies for dynamic look (especially for polyhedrons)
                e.mesh.rotation.x += 2 * delta;
                e.mesh.rotation.z += 1 * delta;

                if (e.mesh.position.distanceTo(playerMesh.position) < 1.2) {
                    GAME.player.hp -= 20 * delta;
                    // Sound: Hit (Throttle slightly to avoid ear damage)
                    if (Math.random() > 0.9) AUDIO.hit();
                }
            });

            // --- DROPS & PARTICLES ---
            for (let i = GAME.drops.length - 1; i >= 0; i--) {
                const d = GAME.drops[i];
                const dist = d.mesh.position.distanceTo(playerMesh.position);
                d.mesh.rotation.y += 2 * delta;
                if (dist < 5) {
                    d.mesh.position.lerp(playerMesh.position, 5 * delta);
                    if (dist < 1) {
                        // Sound: Coin/XP
                        AUDIO.coin();

                        if(d.type === 'xp') GAME.player.xp += d.value;
                        else GAME.player.coins += d.value;
                        scene.remove(d.mesh);
                        GAME.drops.splice(i, 1);
                        checkLevelUp();
                    }
                }
            }

            for (let i = GAME.particles.length - 1; i >= 0; i--) {
                const p = GAME.particles[i];
                p.life -= delta;
                p.mesh.position.add(p.vel.clone().multiplyScalar(delta));
                p.mesh.scale.multiplyScalar(0.95);
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    GAME.particles.splice(i, 1);
                }
            }

            if (GAME.player.hp <= 0) {
                gameOver();
            }
            updateHUD();
        }

        /**
         * MANAGEMENT
         */
        function startGame() {
            // Initialize Audio Context (Required by browsers on interaction)
            if (!AUDIO.ctx) AUDIO.init();
            if (AUDIO.ctx && AUDIO.ctx.state === 'suspended') AUDIO.ctx.resume();

            // Reset Stats
            GAME.player.hp = 100;
            GAME.player.maxHp = 100;
            GAME.player.lvl = 1;
            GAME.player.xp = 0;
            GAME.player.xpNext = 50;
            GAME.player.coins = 0;
            GAME.player.kills = 0;
            GAME.player.damage = 10;
            GAME.player.fireRate = 0.5;
            GAME.player.speed = CONFIG.playerSpeed;
            GAME.player.projectiles = 1;
            GAME.time = 0;
            
            GAME.enemies.forEach(e => scene.remove(e.mesh));
            GAME.bullets.forEach(b => scene.remove(b.mesh));
            GAME.drops.forEach(d => scene.remove(d.mesh));
            GAME.particles.forEach(p => scene.remove(p.mesh));
            GAME.enemies = [];
            GAME.bullets = [];
            GAME.drops = [];
            GAME.particles = [];

            playerMesh.position.set(0, 0, 0);

            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('gameover-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');

            GAME.active = true;
            GAME.paused = false;
            
            // Reset Clock
            clock.start();
        }

        function gameOver() {
            GAME.active = false;
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('gameover-screen').classList.remove('hidden');

            const m = Math.floor(GAME.time / 60).toString().padStart(2, '0');
            const s = Math.floor(GAME.time % 60).toString().padStart(2, '0');
            document.getElementById('end-time').innerText = `${m}:${s}`;
            document.getElementById('end-lvl').innerText = GAME.player.lvl;
            document.getElementById('end-kills').innerText = GAME.player.kills;
            document.getElementById('end-coins').innerText = GAME.player.coins;
        }

        // --- SHARE FUNCTIONALITY ---
        document.getElementById('share-btn').addEventListener('click', async () => {
            const m = Math.floor(GAME.time / 60).toString().padStart(2, '0');
            const s = Math.floor(GAME.time % 60).toString().padStart(2, '0');
            
            const text = `I survived for ${m}:${s} as an OP orange tabby cat! Level ${GAME.player.lvl}, ${GAME.player.kills} Kills. #TabbySurvivor`;
            
            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Tabby Survivor', text: text });
                } catch (err) {}
            } else {
                navigator.clipboard.writeText(text);
                const btn = document.getElementById('share-btn');
                const original = btn.innerText;
                btn.innerText = "COPIED!";
                setTimeout(() => btn.innerText = original, 2000);
            }
        });

        // Facebook Share Logic
        document.getElementById('fb-btn').addEventListener('click', () => {
            const url = encodeURIComponent(window.location.href);
            const quote = encodeURIComponent(`I reached Level ${GAME.player.lvl} in Tabby Survivor! Can you beat my score?`);
            const fbUrl = `https://www.facebook.com/sharer/sharer.php?u=${url}&quote=${quote}`;
            window.open(fbUrl, 'fb-share', 'width=580,height=296');
        });

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initial Setup
        camera.position.set(0, CONFIG.cameraHeight, CONFIG.cameraOffsetZ);
        camera.lookAt(0, 0, 0);
        
        // Start the Loop
        animate();

    </script>
</body>
</html>
