<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Voxel Cat Survivor - å–µå–µå€–å­˜è€…</title>
    <!-- å¼•å…¥ Three.js 3D å¼•æ“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- CSS æ¨£å¼è¡¨ --- */
        :root {
            --primary: #ff9900;
            --secondary: #2d2d2d;
            --accent: #00ffcc;
            --danger: #ff3333;
            --ui-font: 'Microsoft JhengHei', 'Segoe UI', Tahoma, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden; /* é˜²æ­¢æ²è»¸å‡ºç¾ */
            background-color: #111;
            font-family: var(--ui-font);
            user-select: none; /* ç¦æ­¢é¸å–æ–‡å­— */
        }

        /* 3D ç•«å¸ƒå®¹å™¨ */
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI ä»‹é¢å±¤ (è¦†è“‹åœ¨ 3D ä¸Š) */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° Canvasï¼Œé™¤éé»åˆ°æŒ‰éˆ• */
        }

        /* HUD è³‡è¨Šé¢æ¿ */
        .hud-panel {
            position: absolute;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            color: white;
            font-weight: bold;
            pointer-events: auto;
            border: 2px solid rgba(255, 255, 255, 0.1);
            font-size: 16px;
        }

        #hud-top-left { top: 20px; left: 20px; }
        #hud-top-right { top: 20px; right: 20px; text-align: right; }

        /* ç¶“é©—å€¼æ¢ */
        #xp-bar-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            height: 20px;
            background: #333;
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
        }

        #xp-bar-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #00ffcc);
            transition: width 0.2s;
        }

        #level-indicator {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-weight: 900;
            font-size: 1.2rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        /* å…¨è¢å¹•é¸å–® (é–‹å§‹ã€çµæŸã€å‡ç´š) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 3.5rem;
            color: var(--primary);
            margin-bottom: 10px;
            text-transform: uppercase;
            text-shadow: 4px 4px 0px #fff;
            letter-spacing: 2px;
            text-align: center;
        }
        
        h2 {
            color: white;
            font-size: 1.8rem;
            margin-bottom: 2rem;
        }

        /* æŒ‰éˆ•æ¨£å¼ */
        .btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 153, 0, 0.4);
            margin: 10px;
        }

        .btn:hover {
            transform: scale(1.05);
            background: #ffaa33;
        }

        .btn:active { transform: scale(0.95); }

        /* æ¬¡è¦æŒ‰éˆ• (åˆ†äº«ç”¨) */
        .btn-secondary {
            background: #00aaff;
            box-shadow: 0 4px 15px rgba(0, 170, 255, 0.4);
        }
        .btn-secondary:hover { background: #33bbff; }

        /* å‡ç´šå¡ç‰‡ */
        #upgrade-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .upgrade-card {
            background: #222;
            border: 2px solid #444;
            padding: 20px;
            width: 220px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            color: white;
        }

        .upgrade-card:hover {
            background: #333;
            border-color: var(--primary);
            transform: translateY(-5px);
        }

        .upgrade-title {
            color: var(--primary);
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .upgrade-desc {
            font-size: 0.9rem;
            color: #ccc;
            line-height: 1.4;
        }

        /* åˆ†äº«æˆåŠŸæç¤º (Toast) */
        #toast {
            visibility: hidden;
            min-width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 50px;
            padding: 16px;
            position: fixed;
            z-index: 100;
            left: 50%;
            bottom: 50px;
            transform: translateX(-50%);
            font-size: 1.1rem;
            border: 2px solid var(--accent);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #toast.show {
            visibility: visible;
            opacity: 1;
        }

        .stat-row { margin: 5px 0; }
        .highlight { color: var(--accent); }
    </style>
</head>
<body>

    <!-- 3D å ´æ™¯å®¹å™¨ -->
    <div id="game-container"></div>

    <!-- UI ä»‹é¢å±¤ -->
    <div id="ui-layer">
        
        <!-- åˆ†äº«æç¤ºæ¡† -->
        <div id="toast">é€£çµå·²è¤‡è£½ï¼</div>

        <!-- éŠæˆ²ä¸­ HUD -->
        <div id="hud" class="hidden">
            <div id="hud-top-left" class="hud-panel">
                <div class="stat-row">ç”Ÿå‘½: <span id="hp-display" class="highlight">100/100</span></div>
                <div class="stat-row">æ³¢æ•¸: <span id="wave-display">1</span></div>
            </div>

            <div id="xp-bar-container">
                <div id="xp-bar-fill"></div>
            </div>
            <div id="level-indicator">LVL 1</div>

            <div id="hud-top-right" class="hud-panel">
                <div class="stat-row">åˆ†æ•¸: <span id="score-display" class="highlight">0</span></div>
                <div class="stat-row">æ™‚é–“: <span id="time-display">00:00</span></div>
            </div>
        </div>

        <!-- é–‹å§‹ç•«é¢ -->
        <div id="start-screen" class="screen">
            <h1>å–µå–µå€–å­˜è€…</h1>
            <h2>é«”ç´ å¤§äº‚é¬¥</h2>
            <p style="color:#aaa; margin-bottom: 30px; max-width: 400px; text-align: center; line-height: 1.6;">
                ä½¿ç”¨ <b>WASD</b> æˆ– <b>æ–¹å‘éµ</b> ç§»å‹•<br>
                è§’è‰²æœƒè‡ªå‹•ç„æº–æœ€è¿‘çš„æ•µäººå°„æ“Š<br>
                æ”¶é›†æ‰è½çš„å¯¶çŸ³ä¾†å‡ç´šæŠ€èƒ½ï¼
            </p>
            <button class="btn" onclick="game.start()">é–‹å§‹éŠæˆ²</button>
        </div>

        <!-- å‡ç´šé¸å–® -->
        <div id="levelup-screen" class="screen hidden">
            <h1 style="font-size: 3rem; color: var(--accent);">ç­‰ç´šæå‡ï¼</h1>
            <p style="color: white;">è«‹é¸æ“‡ä¸€é …å¼·åŒ–èƒ½åŠ›</p>
            <div id="upgrade-container">
                <!-- JS æœƒåœ¨é€™è£¡æ’å…¥å¡ç‰‡ -->
            </div>
        </div>

        <!-- éŠæˆ²çµæŸç•«é¢ -->
        <div id="gameover-screen" class="screen hidden">
            <h1 style="color: var(--danger);">éŠæˆ²çµæŸ</h1>
            <div class="hud-panel" style="margin-bottom: 30px; text-align: center; min-width: 250px;">
                <div class="stat-row">å­˜æ´»æ™‚é–“: <span id="go-time" class="highlight"></span></div>
                <div class="stat-row">ç­‰ç´š: <span id="go-level" class="highlight"></span></div>
                <div class="stat-row">ç¸½åˆ†: <span id="go-score" class="highlight"></span></div>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="btn" onclick="game.restart()">å†ç©ä¸€æ¬¡</button>
                <button class="btn btn-secondary" onclick="game.share()">åˆ†äº«éŠæˆ²é€£çµ</button>
            </div>
        </div>

    </div>

    <script>
        // --- éŸ³æ•ˆç³»çµ± (Web Audio API) ---
        // ä½¿ç”¨åˆæˆå™¨ç”¢ç”ŸéŸ³æ•ˆï¼Œä¸éœ€è¦ä¸‹è¼‰ mp3
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const sfx = {
            playSound: (type) => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                const now = audioCtx.currentTime;
                
                if (type === 'shoot') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(400 + Math.random()*200, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'hit') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'collect') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, now);
                    osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0.001, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                } else if (type === 'levelup') {
                    gain.gain.value = 0.1;
                    gain.connect(audioCtx.destination);
                    // ç°¡å–®çš„å’Œå¼¦éŸ³æ•ˆ
                    [440, 554, 659, 880].forEach((freq, i) => {
                        const o = audioCtx.createOscillator();
                        o.type = 'triangle';
                        o.frequency.value = freq;
                        o.connect(gain);
                        o.start(now + i * 0.1);
                        o.stop(now + i * 0.1 + 0.3);
                    });
                    return; // ç¨ç«‹è™•ç†
                }

                osc.connect(gain);
                gain.connect(audioCtx.destination);
            }
        };

        // --- éŠæˆ²è¨­å®š ---
        const COLORS = {
            cat: 0xff9900,      // æ©˜è²“
            catStripe: 0xcc7700,
            grass: 0x222222,    // æ·±è‰²èƒŒæ™¯æ¯”è¼ƒè­·çœ¼
            grid: 0x333333,
            enemy: 0xff3333,    // ç´…è‰²æ•µäºº
            bullet: 0x00ffff,   // é’è‰²å­å½ˆ
            gem: 0x00ff00,      // ç¶ è‰²å¯¶çŸ³
            coin: 0xffd700
        };

        let scene, camera, renderer;
        let player, enemies = [], bullets = [], particles = [], loot = [];
        let lastTime = 0;
        let keys = {};
        
        // éŠæˆ²ç‹€æ…‹
        const gameState = {
            status: 'MENU', // MENU, PLAYING, PAUSED, GAMEOVER
            score: 0,
            time: 0,
            wave: 1,
            xp: 0,
            level: 1,
            nextLevelXp: 10,
            enemySpawnTimer: 0,
            enemySpawnRate: 1.5,
        };

        // ç©å®¶æ•¸å€¼
        const playerStats = {
            speed: 10,
            hp: 100,
            maxHp: 100,
            damage: 10,
            fireRate: 0.4,
            fireTimer: 0,
            projectiles: 1,
            projectileSpeed: 20,
            pickupRange: 5,
            bulletSize: 0.4
        };

        // --- Three.js åˆå§‹åŒ– ---
        function initThree() {
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            
            // è¨­å®šç›¸æ©Ÿ (ç­‰è§’è¦–è§’ Isometric)
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(20, 30, 20); 
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // ç‡ˆå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // åœ°æ¿
            const gridHelper = new THREE.GridHelper(100, 50, COLORS.grid, COLORS.grid);
            scene.add(gridHelper);
            
            const planeGeo = new THREE.PlaneGeometry(100, 100);
            const planeMat = new THREE.MeshStandardMaterial({ color: COLORS.grass });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            plane.receiveShadow = true;
            scene.add(plane);

            // è¦–çª—ç¸®æ”¾è™•ç†
            window.addEventListener('resize', () => {
                const aspect = window.innerWidth / window.innerHeight;
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- å»ºç«‹ 3D æ¨¡å‹ (Voxel é¢¨æ ¼) ---
        
        // å»ºç«‹è²“å’ª
        function createVoxelCat() {
            const group = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: COLORS.cat });
            const stripeMat = new THREE.MeshStandardMaterial({ color: COLORS.catStripe });

            // èº«é«”
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1.5), bodyMat);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);

            // é ­
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), bodyMat);
            head.position.set(0, 1, 0.5);
            head.castShadow = true;
            group.add(head);

            // è€³æœµ
            const earGeo = new THREE.ConeGeometry(0.2, 0.4, 4);
            const earL = new THREE.Mesh(earGeo, stripeMat);
            earL.position.set(-0.3, 1.4, 0.5);
            earL.rotation.y = -0.5;
            const earR = new THREE.Mesh(earGeo, stripeMat);
            earR.position.set(0.3, 1.4, 0.5);
            earR.rotation.y = 0.5;
            group.add(earL, earR);

            // å°¾å·´
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.8), stripeMat);
            tail.position.set(0, 0.6, -0.8);
            tail.rotation.x = 0.5;
            group.add(tail);

            return group;
        }

        // å»ºç«‹æ•µäºº
        function createVoxelEnemy(type = 'slime') {
            const group = new THREE.Group();
            let color = type === 'slime' ? 0x55ff55 : 0xff3333;
            if(type === 'boss') color = 0x8800ff;

            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2 });
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat);
            mesh.position.y = 0.5;
            mesh.castShadow = true;
            
            if(type === 'boss') {
                mesh.scale.set(2,2,2);
                mesh.position.y = 1;
            }

            group.add(mesh);
            group.userData = { type: type };
            return group;
        }

        // --- éŠæˆ²é‚è¼¯ ---

        function spawnPlayer() {
            if (player) scene.remove(player);
            player = createVoxelCat();
            scene.add(player);
            
            // é‡ç½®æ•¸æ“š
            playerStats.hp = playerStats.maxHp;
            playerStats.speed = 10;
            playerStats.damage = 10;
            playerStats.fireRate = 0.4;
            playerStats.projectiles = 1;
            playerStats.bulletSize = 0.4;
            playerStats.pickupRange = 5;

            gameState.xp = 0;
            gameState.level = 1;
            gameState.nextLevelXp = 10;
            gameState.time = 0;
            gameState.score = 0;
        }

        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 10; 
            const x = player.position.x + Math.cos(angle) * radius;
            const z = player.position.z + Math.sin(angle) * radius;

            const isBoss = Math.random() < 0.05 && gameState.time > 60;
            const enemy = createVoxelEnemy(isBoss ? 'boss' : 'slime');
            enemy.position.set(x, 0, z);
            
            // é›£åº¦éš¨æ™‚é–“å¢åŠ 
            const diffFactor = 1 + (gameState.time / 60);
            
            enemy.userData.hp = (isBoss ? 100 : 20) * diffFactor;
            enemy.userData.speed = (isBoss ? 3 : 4) + (gameState.time/120); 
            enemy.userData.damage = isBoss ? 20 : 10;
            
            scene.add(enemy);
            enemies.push(enemy);
        }

        // ç©å®¶æ§åˆ¶
        function updatePlayer(dt) {
            const moveDir = new THREE.Vector3(0, 0, 0);
            if (keys['ArrowUp'] || keys['w']) moveDir.z -= 1;
            if (keys['ArrowDown'] || keys['s']) moveDir.z += 1;
            if (keys['ArrowLeft'] || keys['a']) moveDir.x -= 1;
            if (keys['ArrowRight'] || keys['d']) moveDir.x += 1;

            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(playerStats.speed * dt);
                player.position.add(moveDir);
                player.lookAt(player.position.clone().add(moveDir));
                player.position.y = 0.5 + Math.sin(gameState.time * 15) * 0.1; // èµ°è·¯è·³å‹•
            }

            // é™åˆ¶é‚Šç•Œ
            player.position.x = Math.max(-45, Math.min(45, player.position.x));
            player.position.z = Math.max(-45, Math.min(45, player.position.z));

            // ç›¸æ©Ÿè·Ÿéš¨
            const targetPos = player.position.clone().add(new THREE.Vector3(20, 30, 20));
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(player.position);

            // è‡ªå‹•å°„æ“Š
            playerStats.fireTimer -= dt;
            if (playerStats.fireTimer <= 0) {
                let nearest = null;
                let minDist = 20;
                
                enemies.forEach(e => {
                    const d = player.position.distanceTo(e.position);
                    if(d < minDist) { minDist = d; nearest = e; }
                });

                if (nearest) {
                    const dir = new THREE.Vector3().subVectors(nearest.position, player.position).normalize();
                    
                    // æ•£å°„é‚è¼¯
                    if (playerStats.projectiles === 1) {
                        createBullet(dir);
                    } else {
                        const spread = 0.3; 
                        const startAngle = -spread * (playerStats.projectiles - 1) / 2;
                        for(let i=0; i<playerStats.projectiles; i++) {
                            // æ—‹è½‰å‘é‡
                            const x = dir.x * Math.cos(startAngle + i*spread) - dir.z * Math.sin(startAngle + i*spread);
                            const z = dir.x * Math.sin(startAngle + i*spread) + dir.z * Math.cos(startAngle + i*spread);
                            createBullet(new THREE.Vector3(x, 0, z));
                        }
                    }
                    playerStats.fireTimer = playerStats.fireRate;
                }
            }
        }

        function createBullet(direction) {
            const geo = new THREE.BoxGeometry(playerStats.bulletSize, playerStats.bulletSize, playerStats.bulletSize);
            const mat = new THREE.MeshStandardMaterial({ color: COLORS.bullet, emissive: COLORS.bullet, emissiveIntensity: 0.8 });
            const bullet = new THREE.Mesh(geo, mat);
            
            bullet.position.copy(player.position);
            bullet.position.y = 0.8;
            
            bullet.userData = { 
                velocity: direction.normalize().multiplyScalar(playerStats.projectileSpeed), 
                life: 2 
            };
            scene.add(bullet);
            bullets.push(bullet);
            sfx.playSound('shoot');
        }

        // æ•µäººèˆ‡å­å½ˆæ›´æ–°
        function updateEntities(dt) {
            // æ›´æ–°æ•µäºº
            gameState.enemySpawnTimer -= dt;
            if (gameState.enemySpawnTimer <= 0) {
                spawnEnemy();
                gameState.enemySpawnTimer = Math.max(0.2, gameState.enemySpawnRate - (gameState.time * 0.005));
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
                e.position.add(dir.multiplyScalar(e.userData.speed * dt));
                e.lookAt(player.position);

                if (e.position.distanceTo(player.position) < 1.0) {
                    playerStats.hp -= e.userData.damage * dt;
                    updateHUD();
                    if (playerStats.hp <= 0) game.over();
                }
            }

            // æ›´æ–°å­å½ˆ
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.add(b.userData.velocity.clone().multiplyScalar(dt));
                b.userData.life -= dt;

                if (b.userData.life <= 0) {
                    scene.remove(b); bullets.splice(i, 1); continue;
                }

                // ç¢°æ’æª¢æ¸¬
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (b.position.distanceTo(e.position) < 1.2) {
                        e.userData.hp -= playerStats.damage;
                        sfx.playSound('hit');
                        
                        // æ“Šä¸­ç²’å­æ•ˆæœ
                        createParticle(e.position, 0xff9900);

                        if (e.userData.hp <= 0) {
                            createParticle(e.position, 0xff3333, 8); // æ­»äº¡çˆ†ç‚¸
                            createLoot(e.position, Math.random() > 0.8 ? 'coin' : 'xp');
                            scene.remove(e); enemies.splice(j, 1);
                            gameState.score += 100;
                        }
                        hit = true;
                        break; 
                    }
                }
                if (hit) { scene.remove(b); bullets.splice(i, 1); }
            }
        }

        function createLoot(pos, type) {
            const geo = type === 'xp' ? new THREE.OctahedronGeometry(0.3) : new THREE.BoxGeometry(0.3, 0.1, 0.3);
            const color = type === 'xp' ? COLORS.gem : COLORS.coin;
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: color, emissive: color }));
            mesh.position.copy(pos);
            mesh.position.y = 0.5;
            mesh.userData = { type: type, value: type==='xp'?10:50 };
            scene.add(mesh);
            loot.push(mesh);
        }

        function updateLoot(dt) {
            for (let i = loot.length - 1; i >= 0; i--) {
                const l = loot[i];
                const dist = l.position.distanceTo(player.position);
                
                if (dist < playerStats.pickupRange) {
                    const dir = new THREE.Vector3().subVectors(player.position, l.position).normalize();
                    l.position.add(dir.multiplyScalar(12 * dt));
                    
                    if (dist < 1.0) {
                        if (l.userData.type === 'xp') addXP(l.userData.value);
                        else gameState.score += l.userData.value;
                        sfx.playSound('collect');
                        scene.remove(l); loot.splice(i, 1);
                    }
                } else {
                    l.rotation.y += dt;
                }
            }
        }

        function createParticle(pos, color, count=3) {
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.userData = { vel: new THREE.Vector3((Math.random()-0.5)*5, Math.random()*5, (Math.random()-0.5)*5) };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function updateParticles(dt) {
            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel.clone().multiplyScalar(dt));
                p.userData.vel.y -= 9.8 * dt; // é‡åŠ›
                p.scale.multiplyScalar(0.9);
                if(p.scale.x < 0.01 || p.position.y < 0) {
                    scene.remove(p); particles.splice(i, 1);
                }
            }
        }

        // --- å‡ç´šç³»çµ± ---
        function addXP(amount) {
            gameState.xp += amount;
            if (gameState.xp >= gameState.nextLevelXp) {
                gameState.xp -= gameState.nextLevelXp;
                gameState.level++;
                gameState.nextLevelXp = Math.floor(gameState.nextLevelXp * 1.5);
                showLevelUp();
            }
            updateHUD();
        }

        function showLevelUp() {
    // æš«åœéŠæˆ²
    gameState.status = 'PAUSED';
    sfx.playSound('levelup');

    const upgrades = [
        { title: "é‹’åˆ©è²“çˆª", desc: "+20% å‚·å®³", func: () => playerStats.damage *= 1.2 },
        { title: "è²“æ­¥è¼•ç›ˆ", desc: "+20% ç§»å‹•é€Ÿåº¦", func: () => playerStats.speed *= 1.2 },
        { title: "ç˜‹ç‹‚æŠ“æŠ“", desc: "+20% æ”»æ“Šé€Ÿåº¦", func: () => playerStats.fireRate *= 0.8 },
        { title: "å½±åˆ†èº«çˆª", desc: "+1 é¡å¤–å­å½ˆ", func: () => playerStats.projectiles += 1 },
        { title: "ä¹å‘½æ€ªè²“", desc: "å›å¾© 50% è¡€é‡ + è¡€é‡ä¸Šé™", func: () => {
            playerStats.maxHp += 20;
            playerStats.hp = Math.min(playerStats.hp + playerStats.maxHp / 2, playerStats.maxHp);
        }},
        { title: "å·¨å¤§æ¯›çƒ", desc: "å­å½ˆè®Šå¤§ +10% å‚·å®³", func: () => {
            playerStats.bulletSize *= 1.3;
            playerStats.damage *= 1.1;
        }}
    ];

    const container = document.getElementById('upgrade-container');
    container.innerHTML = '';

    // éš¨æ©ŸæŠ½ 3 å¼µå‡ç´šå¡
    const choices = upgrades.sort(() => 0.5 - Math.random()).slice(0, 3);

    choices.forEach(u => {
        const div = document.createElement('div');
        div.className = 'upgrade-card';
        div.innerHTML = `
            <div class="upgrade-title">${u.title}</div>
            <div class="upgrade-desc">${u.desc}</div>
        `;

        div.addEventListener('click', () => {
            // å¥—ç”¨å‡ç´šæ•ˆæœ
            u.func();

            // é—œé–‰å‡ç´šç•«é¢ï¼Œæ¢å¾©éŠæˆ²
            document.getElementById('levelup-screen').classList.add('hidden');
            gameState.status = 'PLAYING';
            lastTime = performance.now(); // é¿å…å¤§ dt
            updateHUD();

            // ğŸ” é‡æ–°å•Ÿå‹•å‹•ç•«è¿´åœˆ
            requestAnimationFrame(animate);
        });

        // âœ… æŠŠå¡ç‰‡çœŸçš„åŠ é€²ç•«é¢
        container.appendChild(div);
    });

    // é¡¯ç¤ºå‡ç´šç•«é¢
    document.getElementById('levelup-screen').classList.remove('hidden');
}

        // --- éŠæˆ²æµç¨‹æ§åˆ¶ ---
        const game = {
            start: () => {
                spawnPlayer();
                enemies.forEach(e => scene.remove(e)); enemies = [];
                bullets.forEach(b => scene.remove(b)); bullets = [];
                loot.forEach(l => scene.remove(l)); loot = [];
                particles.forEach(p => scene.remove(p)); particles = [];

                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('gameover-screen').classList.add('hidden');
                document.getElementById('hud').classList.remove('hidden');
                
                gameState.status = 'PLAYING';
                lastTime = performance.now();
                requestAnimationFrame(animate);
            },
            restart: () => {
                game.start();
            },
            over: () => {
                gameState.status = 'GAMEOVER';
                document.getElementById('hud').classList.add('hidden');
                document.getElementById('gameover-screen').classList.remove('hidden');
                document.getElementById('go-score').innerText = gameState.score;
                document.getElementById('go-level').innerText = gameState.level;
                
                const mins = Math.floor(gameState.time / 60).toString().padStart(2, '0');
                const secs = Math.floor(gameState.time % 60).toString().padStart(2, '0');
                document.getElementById('go-time').innerText = `${mins}:${secs}`;
            },
            share: () => {
                const url = window.location.href;
                // å»ºç«‹è‡¨æ™‚å…ƒç´ ä»¥è¤‡è£½æ–‡å­—
                const tempInput = document.createElement("input");
                document.body.appendChild(tempInput);
                tempInput.value = url;
                tempInput.select();
                document.execCommand("copy");
                document.body.removeChild(tempInput);

                // é¡¯ç¤ºæç¤º Toast
                const toast = document.getElementById('toast');
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 2000);
            }
        };

        function updateHUD() {
            document.getElementById('hp-display').innerText = `${Math.floor(playerStats.hp)}/${Math.floor(playerStats.maxHp)}`;
            document.getElementById('score-display').innerText = gameState.score;
            document.getElementById('wave-display').innerText = Math.floor(gameState.time/30)+1;
            document.getElementById('level-indicator').innerText = `LVL ${gameState.level}`;
            document.getElementById('xp-bar-fill').style.width = `${(gameState.xp / gameState.nextLevelXp) * 100}%`;
            
            const mins = Math.floor(gameState.time / 60).toString().padStart(2, '0');
            const secs = Math.floor(gameState.time % 60).toString().padStart(2, '0');
            document.getElementById('time-display').innerText = `${mins}:${secs}`;
        }

        function animate(now) {
            if (gameState.status !== 'PLAYING') return;
            requestAnimationFrame(animate);

            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            gameState.time += dt;

            updatePlayer(dt);
            updateEntities(dt);
            updateLoot(dt);
            updateParticles(dt);
            updateHUD();
            
            renderer.render(scene, camera);
        }

        // éµç›¤ç›£è½
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        // å•Ÿå‹• Three.js
        initThree();

    </script>
</body>
</html>
